---
import Layout from '../../layouts/Layout.astro';
import { ui, languages } from '../../i18n/ui';

export function getStaticPaths() {
  return Object.keys(languages).map((lang) => ({ params: { lang } }));
}

const { lang } = Astro.params;
const t = ui[lang as keyof typeof ui] ?? ui.en;

const labels = {
  statusReady: t['maze.status.ready'],
  statusPlaying: t['maze.status.playing'],
  statusDone: t['maze.status.done'],
  showBest: t['maze.showBest'],
  hideBest: t['maze.hideBest'],
  hint: t['maze.hint'],
};
---

<Layout title={`${t['maze.title']} | Sakasu Portfolio`} lang={lang}>
  <section class="py-10 md:py-14 relative overflow-hidden">
    <div aria-hidden="true" class="pointer-events-none absolute -top-24 -left-14 w-72 h-72 rounded-full bg-cyan-500/12 blur-3xl"></div>
    <div aria-hidden="true" class="pointer-events-none absolute -bottom-20 right-0 w-80 h-80 rounded-full bg-emerald-500/10 blur-3xl"></div>

    <div class="relative rounded-2xl border border-cyan-500/20 bg-[#0f1728]/70 backdrop-blur-sm p-6 md:p-8 shadow-[0_0_0_1px_rgba(34,211,238,0.08),0_18px_50px_rgba(2,6,23,0.72)]">
      <h1 class="text-3xl md:text-5xl font-extrabold bg-gradient-to-r from-white via-cyan-100 to-emerald-300 bg-clip-text text-transparent">
        {t['maze.title']}
      </h1>
      <p class="mt-4 text-gray-200 max-w-2xl leading-relaxed">
        {t['maze.subtitle']}
      </p>
      <p class="mt-2 text-sm text-gray-400 max-w-2xl">{t['maze.instructions']}</p>
    </div>

    <section id="maze-lab" class="maze-lab-shell mt-8 space-y-6 rounded-2xl border border-gray-800/80 bg-[#10131d]/88 p-4 md:p-6">
      <div class="grid grid-cols-2 md:grid-cols-4 gap-3 md:gap-4">
        <article class="maze-metric-card rounded-xl border border-blue-500/20 bg-[#0e1524]/90 p-4">
          <p class="text-xs uppercase tracking-widest text-blue-200/70">{t['maze.moves']}</p>
          <p id="maze-moves" class="mt-2 text-2xl md:text-3xl font-bold text-white">0</p>
        </article>
        <article class="maze-metric-card rounded-xl border border-emerald-500/20 bg-[#0e1524]/90 p-4">
          <p class="text-xs uppercase tracking-widest text-emerald-200/70">{t['maze.bestMoves']}</p>
          <p id="maze-best-moves" class="mt-2 text-2xl md:text-3xl font-bold text-white">--</p>
        </article>
        <article class="maze-metric-card rounded-xl border border-amber-500/20 bg-[#0e1524]/90 p-4">
          <p class="text-xs uppercase tracking-widest text-amber-200/70">{t['maze.extraMoves']}</p>
          <p id="maze-extra-moves" class="mt-2 text-2xl md:text-3xl font-bold text-amber-200">--</p>
        </article>
        <article class="maze-metric-card rounded-xl border border-cyan-500/20 bg-[#0e1524]/90 p-4">
          <p class="text-xs uppercase tracking-widest text-cyan-200/70">{t['maze.seed']}</p>
          <p id="maze-seed" class="mt-2 text-2xl md:text-3xl font-bold text-white">--</p>
        </article>
      </div>

      <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
        <button
          id="maze-new-map"
          type="button"
          class="maze-action-btn w-full px-3 py-2 text-xs md:text-sm rounded-md border border-blue-600/40 bg-blue-600/10 text-blue-100 hover:text-white hover:border-blue-400 transition-colors"
        >
          {t['maze.newMap']}
        </button>
        <button
          id="maze-reset-run"
          type="button"
          class="maze-action-btn w-full px-3 py-2 text-xs md:text-sm rounded-md border border-cyan-600/40 bg-cyan-600/10 text-cyan-100 hover:text-white hover:border-cyan-400 transition-colors"
        >
          {t['maze.resetRun']}
        </button>
        <button
          id="maze-toggle-best"
          type="button"
          class="maze-action-btn w-full px-3 py-2 text-xs md:text-sm rounded-md border border-emerald-600/40 bg-emerald-600/10 text-emerald-100 hover:text-white hover:border-emerald-400 transition-colors"
        >
          {t['maze.showBest']}
        </button>
      </div>

      <div class="maze-board-shell rounded-xl border p-2 md:p-3">
        <div id="maze-board" class="maze-board" style="--maze-cols: 11"></div>
      </div>

      <div class="flex flex-wrap gap-4 text-xs text-gray-300">
        <span class="inline-flex items-center gap-2">
          <span class="maze-legend-swatch maze-legend-user"></span>
          {t['maze.legend.you']}
        </span>
        <span class="inline-flex items-center gap-2">
          <span class="maze-legend-swatch maze-legend-best"></span>
          {t['maze.legend.best']}
        </span>
        <span class="inline-flex items-center gap-2">
          <span class="maze-legend-swatch maze-legend-start">S</span>
          {t['maze.legend.start']}
        </span>
        <span class="inline-flex items-center gap-2">
          <span class="maze-legend-swatch maze-legend-goal">G</span>
          {t['maze.legend.goal']}
        </span>
      </div>

      <p id="maze-status" class="maze-status-pill inline-flex text-sm text-blue-200">{t['maze.status.ready']}</p>
      <p id="maze-hint" class="text-xs text-gray-500">{t['maze.hint']}</p>
    </section>
  </section>
</Layout>

<script define:vars={{ labels }}>
  const ROWS = 11;
  const COLS = 11;
  const MIN_SHORTEST_STEPS = 18;
  const START = Object.freeze({ r: 1, c: 1 });
  const GOAL = Object.freeze({ r: ROWS - 2, c: COLS - 2 });
  const DIRECTIONS = [
    { dr: 1, dc: 0 },
    { dr: -1, dc: 0 },
    { dr: 0, dc: 1 },
    { dr: 0, dc: -1 },
  ];

  function mulberry32(seed) {
    let t = seed >>> 0;
    return () => {
      t += 0x6d2b79f5;
      let x = t;
      x = Math.imul(x ^ (x >>> 15), x | 1);
      x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  function getSeed() {
    if (window.crypto?.getRandomValues) {
      const data = new Uint32Array(1);
      window.crypto.getRandomValues(data);
      return data[0];
    }
    return Math.floor(Math.random() * 4294967295);
  }

  function isInside(r, c) {
    return r >= 0 && r < ROWS && c >= 0 && c < COLS;
  }

  function pointKey(point) {
    return `${point.r},${point.c}`;
  }

  function clonePoint(point) {
    return { r: point.r, c: point.c };
  }

  function shuffle(array, random) {
    for (let i = array.length - 1; i > 0; i -= 1) {
      const j = Math.floor(random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  function generateMaze(seed) {
    const random = mulberry32(seed);
    const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(1));

    function carve(r, c) {
      grid[r][c] = 0;
      const longSteps = shuffle(
        DIRECTIONS.map(({ dr, dc }) => ({ dr: dr * 2, dc: dc * 2 })),
        random
      );

      for (const { dr, dc } of longSteps) {
        const nr = r + dr;
        const nc = c + dc;
        if (!isInside(nr, nc) || nr <= 0 || nr >= ROWS - 1 || nc <= 0 || nc >= COLS - 1) {
          continue;
        }
        if (grid[nr][nc] !== 1) continue;

        grid[r + dr / 2][c + dc / 2] = 0;
        carve(nr, nc);
      }
    }

    carve(START.r, START.c);

    const additionalOpenings = Math.floor((ROWS * COLS) * 0.07);
    for (let i = 0; i < additionalOpenings; i += 1) {
      const r = 1 + Math.floor(random() * (ROWS - 2));
      const c = 1 + Math.floor(random() * (COLS - 2));
      if (grid[r][c] === 0) continue;

      let openNeighbors = 0;
      for (const { dr, dc } of DIRECTIONS) {
        const nr = r + dr;
        const nc = c + dc;
        if (isInside(nr, nc) && grid[nr][nc] === 0) {
          openNeighbors += 1;
        }
      }

      if (openNeighbors >= 2 && random() > 0.25) {
        grid[r][c] = 0;
      }
    }

    grid[START.r][START.c] = 0;
    grid[GOAL.r][GOAL.c] = 0;

    return grid;
  }

  function findShortestPath(grid, start, goal) {
    const queue = [clonePoint(start)];
    const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    const previous = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    visited[start.r][start.c] = true;

    for (let head = 0; head < queue.length; head += 1) {
      const current = queue[head];
      if (current.r === goal.r && current.c === goal.c) break;

      for (const { dr, dc } of DIRECTIONS) {
        const nr = current.r + dr;
        const nc = current.c + dc;
        if (!isInside(nr, nc) || visited[nr][nc] || grid[nr][nc] === 1) continue;
        visited[nr][nc] = true;
        previous[nr][nc] = current;
        queue.push({ r: nr, c: nc });
      }
    }

    if (!visited[goal.r][goal.c]) return [];

    const path = [];
    let cursor = clonePoint(goal);
    while (cursor) {
      path.push(cursor);
      const prev = previous[cursor.r][cursor.c];
      if (!prev) break;
      cursor = clonePoint(prev);
    }

    return path.reverse();
  }

  function buildPlayableMaze(seedCandidate) {
    let seed = seedCandidate >>> 0;
    let grid = generateMaze(seed);
    let shortestPath = findShortestPath(grid, START, GOAL);

    for (let attempt = 0; attempt < 48; attempt += 1) {
      if (shortestPath.length && shortestPath.length - 1 >= MIN_SHORTEST_STEPS) {
        return { seed, grid, shortestPath };
      }
      seed = (seed + 0x9e3779b9) >>> 0;
      grid = generateMaze(seed);
      shortestPath = findShortestPath(grid, START, GOAL);
    }

    return { seed, grid, shortestPath };
  }

  function initMazeLab() {
    const root = document.getElementById('maze-lab');
    if (!root || root.dataset.ready === 'true') return;
    root.dataset.ready = 'true';

    const boardEl = root.querySelector('#maze-board');
    const movesEl = root.querySelector('#maze-moves');
    const bestMovesEl = root.querySelector('#maze-best-moves');
    const extraMovesEl = root.querySelector('#maze-extra-moves');
    const seedEl = root.querySelector('#maze-seed');
    const statusEl = root.querySelector('#maze-status');
    const hintEl = root.querySelector('#maze-hint');

    const newMapBtn = root.querySelector('#maze-new-map');
    const resetRunBtn = root.querySelector('#maze-reset-run');
    const toggleBestBtn = root.querySelector('#maze-toggle-best');

    if (!boardEl) return;

    let seed = 0;
    let grid = [];
    let shortestPath = [];
    let playerPath = [clonePoint(START)];
    let current = clonePoint(START);
    let moveCount = 0;
    let finished = false;
    let showBest = false;

    function setText(node, value) {
      if (node) node.textContent = value;
    }

    function isOpenCell(r, c) {
      return isInside(r, c) && grid[r][c] === 0;
    }

    function isNeighbor(from, to) {
      return Math.abs(from.r - to.r) + Math.abs(from.c - to.c) === 1;
    }

    function getShortestSteps() {
      return shortestPath.length ? shortestPath.length - 1 : null;
    }

    function resetRun() {
      playerPath = [clonePoint(START)];
      current = clonePoint(START);
      moveCount = 0;
      finished = false;
      showBest = true;
      render();
    }

    function createNewMaze() {
      const generated = buildPlayableMaze(getSeed());
      seed = generated.seed;
      grid = generated.grid;
      shortestPath = generated.shortestPath;
      resetRun();
    }

    function renderStats() {
      const shortestSteps = getShortestSteps();
      setText(movesEl, String(moveCount));
      setText(bestMovesEl, shortestSteps === null ? '--' : String(shortestSteps));
      setText(seedEl, String(seed));

      if (!finished || shortestSteps === null) {
        setText(extraMovesEl, '--');
      } else {
        const diff = Math.max(moveCount - shortestSteps, 0);
        setText(extraMovesEl, diff ? `+${diff}` : '0');
      }

      if (statusEl) {
        if (finished) {
          statusEl.className = 'maze-status-pill inline-flex text-sm text-emerald-200';
          setText(statusEl, labels.statusDone);
        } else if (moveCount > 0) {
          statusEl.className = 'maze-status-pill inline-flex text-sm text-cyan-200';
          setText(statusEl, labels.statusPlaying);
        } else {
          statusEl.className = 'maze-status-pill inline-flex text-sm text-blue-200';
          setText(statusEl, labels.statusReady);
        }
      }

      setText(hintEl, labels.hint);

      if (toggleBestBtn) {
        toggleBestBtn.textContent = showBest ? labels.hideBest : labels.showBest;
      }
    }

    function renderBoard() {
      const userPathSet = new Set(playerPath.map(pointKey));
      const bestPathSet = showBest ? new Set(shortestPath.map(pointKey)) : new Set();

      boardEl.innerHTML = '';

      for (let r = 0; r < ROWS; r += 1) {
        for (let c = 0; c < COLS; c += 1) {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'maze-cell';
          button.dataset.r = String(r);
          button.dataset.c = String(c);

          if (grid[r][c] === 1) {
            button.disabled = true;
            button.classList.add('is-wall');
            boardEl.appendChild(button);
            continue;
          }

          const point = { r, c };
          const key = pointKey(point);
          button.classList.add('is-open');

          const onBestPath = bestPathSet.has(key);
          const onUserPath = userPathSet.has(key);

          if (onBestPath) {
            button.classList.add('is-best');
          }

          if (onUserPath) {
            button.classList.add('is-user');
            if ((r !== START.r || c !== START.c) && (r !== GOAL.r || c !== GOAL.c)) {
              button.classList.add('has-route-dot');
            }
          }

          if (onBestPath && onUserPath) {
            button.classList.add('is-overlap');
          }

          if (r === START.r && c === START.c) {
            button.classList.add('is-start');
            button.textContent = 'S';
          }

          if (r === GOAL.r && c === GOAL.c) {
            button.classList.add('is-goal');
            button.textContent = 'G';
          }

          if (r === current.r && c === current.c) {
            button.classList.add('is-current');
          }

          if (!finished && isNeighbor(current, point)) {
            button.classList.add('is-next');
          }

          boardEl.appendChild(button);
        }
      }
    }

    function render() {
      renderStats();
      renderBoard();
    }

    function attemptMove(targetR, targetC) {
      if (finished) return;
      if (!isOpenCell(targetR, targetC)) return;

      const target = { r: targetR, c: targetC };
      if (!isNeighbor(current, target)) return;

      current = target;
      playerPath.push(clonePoint(target));
      moveCount += 1;

      if (target.r === GOAL.r && target.c === GOAL.c) {
        finished = true;
        showBest = true;
      }

      render();
    }

    boardEl.addEventListener('click', (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;

      const cell = target.closest('button[data-r][data-c]');
      if (!cell) return;

      const r = Number(cell.dataset.r);
      const c = Number(cell.dataset.c);
      if (!Number.isInteger(r) || !Number.isInteger(c)) return;
      attemptMove(r, c);
    });

    if (newMapBtn) {
      newMapBtn.addEventListener('click', createNewMaze);
    }

    if (resetRunBtn) {
      resetRunBtn.addEventListener('click', resetRun);
    }

    if (toggleBestBtn) {
      toggleBestBtn.addEventListener('click', () => {
        showBest = !showBest;
        render();
      });
    }

    createNewMaze();
  }

  function bootMazeLab() {
    initMazeLab();
  }

  bootMazeLab();
  if (!window.__mazeLabPageLoadListener) {
    document.addEventListener('astro:page-load', bootMazeLab);
    window.__mazeLabPageLoadListener = true;
  }
</script>

<style is:global>
  .maze-lab-shell {
    background-image:
      radial-gradient(circle at 0% 0%, rgba(34, 211, 238, 0.1), transparent 42%),
      radial-gradient(circle at 100% 0%, rgba(16, 185, 129, 0.1), transparent 44%),
      linear-gradient(180deg, rgba(15, 23, 42, 0.36), rgba(2, 6, 23, 0.56));
    box-shadow:
      0 18px 40px rgba(2, 6, 23, 0.64),
      inset 0 1px 0 rgba(148, 163, 184, 0.08);
  }

  .maze-metric-card {
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    transition: transform 170ms ease, border-color 170ms ease;
  }

  .maze-metric-card:hover {
    transform: translateY(-2px);
    border-color: rgba(56, 189, 248, 0.52);
  }

  .maze-action-btn {
    backdrop-filter: blur(4px);
    transition: transform 160ms ease, box-shadow 200ms ease;
  }

  .maze-action-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 8px 16px rgba(2, 6, 23, 0.42);
  }

  .maze-board-shell {
    background-image: linear-gradient(180deg, rgba(224, 242, 254, 0.94), rgba(186, 230, 253, 0.88));
    border-color: rgba(14, 116, 144, 0.35);
    box-shadow:
      inset 0 1px 0 rgba(255, 255, 255, 0.8),
      0 12px 24px rgba(2, 6, 23, 0.36);
  }

  .maze-board {
    display: grid;
    grid-template-columns: repeat(var(--maze-cols), minmax(0, 1fr));
    gap: 0.16rem;
    background: rgba(30, 64, 175, 0.28);
    padding: 0.16rem;
    border-radius: 0.42rem;
  }

  .maze-cell {
    aspect-ratio: 1 / 1;
    border-radius: 0.28rem;
    border: 1px solid rgba(30, 41, 59, 0.28);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.72rem;
    font-weight: 700;
    line-height: 1;
    letter-spacing: 0.02em;
    transition: transform 140ms ease, border-color 160ms ease, background-color 160ms ease;
    user-select: none;
    position: relative;
    overflow: hidden;
  }

  .maze-cell.is-wall {
    background: linear-gradient(180deg, rgba(51, 65, 85, 0.96), rgba(30, 41, 59, 0.96));
    border-color: rgba(15, 23, 42, 0.7);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
    cursor: not-allowed;
  }

  .maze-cell.is-open {
    background: linear-gradient(180deg, rgba(248, 250, 252, 0.98), rgba(226, 232, 240, 0.96));
    border-color: rgba(51, 65, 85, 0.35);
    color: rgba(15, 23, 42, 0.94);
  }

  .maze-cell.is-user {
    background: linear-gradient(180deg, rgba(37, 99, 235, 0.96), rgba(30, 64, 175, 0.96));
    border-color: rgba(191, 219, 254, 0.98);
    box-shadow:
      inset 0 0 0 1px rgba(255, 255, 255, 0.2),
      0 0 0 1px rgba(37, 99, 235, 0.52);
    color: #ffffff;
  }

  .maze-cell.is-best {
    background:
      repeating-linear-gradient(
        135deg,
        rgba(22, 163, 74, 0.95) 0 4px,
        rgba(34, 197, 94, 0.68) 4px 8px
      );
    border-color: rgba(187, 247, 208, 0.96);
    box-shadow:
      inset 0 0 0 1px rgba(236, 253, 245, 0.6),
      0 0 0 1px rgba(22, 163, 74, 0.42);
    color: #052e16;
  }

  .maze-cell.is-overlap {
    background:
      linear-gradient(
        135deg,
        rgba(37, 99, 235, 0.95) 0 50%,
        rgba(22, 163, 74, 0.95) 50% 100%
      );
    border-color: rgba(253, 224, 71, 0.95);
    box-shadow:
      inset 0 0 0 1px rgba(255, 255, 255, 0.28),
      0 0 0 2px rgba(234, 179, 8, 0.44);
  }

  .maze-cell.is-start {
    background: linear-gradient(180deg, rgba(2, 132, 199, 0.98), rgba(3, 105, 161, 0.98));
    border-color: rgba(186, 230, 253, 0.98);
    color: #ffffff;
  }

  .maze-cell.is-goal {
    background: linear-gradient(180deg, rgba(245, 158, 11, 0.98), rgba(217, 119, 6, 0.98));
    border-color: rgba(254, 240, 138, 0.96);
    color: #ffffff;
  }

  .maze-cell.is-current {
    outline: 2px solid rgba(15, 23, 42, 0.88);
    outline-offset: -1px;
    box-shadow:
      0 0 0 3px rgba(234, 179, 8, 0.66),
      0 0 20px rgba(234, 179, 8, 0.52);
  }

  .maze-cell.is-next {
    cursor: pointer;
    border-color: rgba(217, 119, 6, 0.95);
    transform: translateY(-1px);
    box-shadow: inset 0 0 0 1px rgba(254, 215, 170, 0.9);
  }

  .maze-cell.is-next:hover {
    border-color: rgba(180, 83, 9, 0.96);
    box-shadow:
      inset 0 0 0 1px rgba(254, 215, 170, 0.98),
      0 0 0 2px rgba(245, 158, 11, 0.42);
  }

  .maze-cell.has-route-dot::after {
    content: '';
    position: absolute;
    inset: 50% auto auto 50%;
    width: 0.42rem;
    height: 0.42rem;
    border-radius: 999px;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.98);
    box-shadow: 0 0 8px rgba(15, 23, 42, 0.24);
    pointer-events: none;
  }

  .maze-cell.is-best.has-route-dot::after {
    background: rgba(254, 240, 138, 0.98);
    box-shadow: 0 0 8px rgba(202, 138, 4, 0.4);
  }

  .maze-status-pill {
    align-items: center;
    gap: 0.5rem;
    border-radius: 999px;
    border: 1px solid rgba(56, 189, 248, 0.4);
    background: rgba(14, 116, 144, 0.12);
    padding: 0.28rem 0.78rem;
    font-weight: 600;
    letter-spacing: 0.01em;
    animation: mazeStatusPulse 2.4s ease-in-out infinite;
  }

  .maze-status-pill::before {
    content: '';
    width: 0.42rem;
    height: 0.42rem;
    border-radius: 999px;
    background: currentColor;
    box-shadow: 0 0 12px currentColor;
  }

  .maze-legend-swatch {
    width: 1.05rem;
    height: 1.05rem;
    border-radius: 0.3rem;
    border: 1px solid rgba(148, 163, 184, 0.52);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.62rem;
    font-weight: 700;
    color: #f8fafc;
  }

  .maze-legend-user {
    background: linear-gradient(180deg, rgba(37, 99, 235, 0.92), rgba(30, 64, 175, 0.92));
    border-color: rgba(191, 219, 254, 0.9);
  }

  .maze-legend-best {
    background: repeating-linear-gradient(
      135deg,
      rgba(22, 163, 74, 0.95) 0 4px,
      rgba(34, 197, 94, 0.68) 4px 8px
    );
    border-color: rgba(187, 247, 208, 0.92);
  }

  .maze-legend-start {
    background: linear-gradient(180deg, rgba(2, 132, 199, 0.98), rgba(3, 105, 161, 0.98));
    border-color: rgba(186, 230, 253, 0.98);
  }

  .maze-legend-goal {
    background: linear-gradient(180deg, rgba(245, 158, 11, 0.98), rgba(217, 119, 6, 0.98));
    border-color: rgba(254, 240, 138, 0.96);
  }

  @keyframes mazeStatusPulse {
    0%,
    100% {
      box-shadow: 0 0 0 0 rgba(34, 211, 238, 0.28);
    }
    50% {
      box-shadow: 0 0 0 8px rgba(34, 211, 238, 0);
    }
  }

  @media (max-width: 640px) {
    .maze-lab-shell {
      padding: 0.82rem;
      gap: 1rem;
    }

    .maze-metric-card {
      padding: 0.75rem;
      border-radius: 0.78rem;
    }

    .maze-board {
      gap: 0.15rem;
      padding: 0.14rem;
    }

    .maze-cell {
      border-radius: 0.24rem;
      font-size: 0.62rem;
    }

    .maze-status-pill {
      font-size: 0.75rem;
      padding: 0.24rem 0.64rem;
      gap: 0.42rem;
    }
  }
</style>
